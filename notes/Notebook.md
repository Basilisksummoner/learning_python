**Notebook из серии лекций МФТИ - Алгоритмы Python**

# Лекция 1
1) `Самый простой алгоритм`
      a = 2
      b = 5
      *Необходимо поменять местами значения a and b*
      *Используем метод третьей переменной*
      *Это как если бы у нас было два стакана, в одном молоко в другом вода*
      *чтобы свапнуть их местами нужен третий стакан т.е 3я перменная*
      a = 2
      b = 5
      tmp = a    #tmp ссылается на то же значение что и а
      a = b
      b = tmp

      **ВАЖНО!!!**
      Питон позволяет менять следующим образом
      a, b = b, a
      НО! Это не обмен без переменной на самом деле это обмен через две временные
    
      Т.е ->
  
      a = 2
      b = 5
      tmp_1,tmp_2 = b,a
      a,b = tmp_1,tmp_2
      a,b = b,a

2) `Арифметические операции` 
      x в степени y = x**y
 
      корень из x = x**0.5
  
      a в степени b в степени c = (a**b**c)

      x* y = умножение
  
      x/y = деление
      x//y = деление без остатка в меньшую сторону

3) `Управляющие конструкции`

      Итерация это одно выполнение тела цикла 
  
      while условие: # заголовок
            if operator 1:   # тело цикла
            operator 2:
            operator N:
            break # можем выйти с середины цикла
      else:

      Цикл может иметь вложенные циклы!!!
  
4) `Суммарно, все операторы присваивания в Python`
      Каскадное присваивание
       a=b=c=0
    
      Множественное присваивание
       a, b, c = 1,2,3

      Синтаксический сахар
       x = x + 1
       x += 1 or x -= 1 Увел или уменьшить на 1
       x *= 1 or x /= 1 Умн или делить на 1

5) `Цикл for` 
      for x in (1,2,3)
    
      for x in range
      Как работет range? (start,stop,step)
      start нижняя граница 
      stop верхняя гранциа за её вычетом т.е если 10 то будет 9
      step на сколько прыгаем 1,2,3 и т.д
      range(1,10,1) - пробежит от 1 до 9и 


  



# Лекция 2
1) `Алгебра логики`
      *math basical logic*
      
      пусть А это True = 1
      пусть B это False = 0

      Функция = отображение множества на множество,
      т.е область определения на множество значения

      Составное высказывание (унарные операции)
      1. not A
      2. A and B  - в алгебре как A * B
      3. A or B  - в алгебре как A + B
      4. Импликация
      5. Эквиваленция

      Т.е 
      1 * 1 = 1 (Это как если сказать истина * на истину будет истина)

2) `Конструкция выбора`
      Тип bool True False
      Логические операции and, or, not
      a == b (оператор сравнения return bool)

      x = int(input())
            if x == 1:
                  print('1')  >>>>>>>>>>>>   if x == 1 or f x == 0
            if x == 0:        записываем как
                  print('0')

# Лекция 3

1) `Описание простых функций` 
      **p.s Одна из важнейших fundametnals**
      **Тут прям базовая база**
      
      def x(a,b):     функция x с условными параметрами a и b
            тело функции

      Но если сделать def x(a=2,b=3) то если взывать ее как x()
            мы подразумеваем что по дефолту у нас а это 2 b это 3
      Это называется дефолтный параметр

      Напишем простую функцию которая на входе принимает на параметра
      и возвращает наибольший из них

      `def max_2(a,b):`
            `if a > b:`
                  `return a`
            `return b`

      Почему я не написал else? Потому что если if statement истина то,
      return прерывает функцию и возвращает а, иначе продолжает идти дальше и b. 
      В else нет нужды. 
      
      *else нужен когда в функции нет return*

      ВАЖНО!!! Cool lifehack
           `def max_3(x,y,z):`
                  `return max_2(x,max_2(y,z))`
      Создадим функцию для расчёта максимального значения уже с 3мя переменными
      Что происходит под капотом? 
      Итак, у нас есть функция max_2 для расчёта макс из двух
      теперь мы в функции max_3 возвращаем max_2 с параметрами х и
      max_2(y,z) т.е max_2(y,z) сначала посчитает что больше из y и z и
      и сравнит с x

      А теперь вопрос, выведет ли:
      print(max_3(1,5,9)) - выведет всё ок
      print(max_3(1,5,9.9)) - выведет даже если какое-то значение float
      print(max_3('ab','abc','ac')) - Шок! но тоже выведет
      
      Это называется `Duck typing`

2) `Call stack`
      Представим что у нас есть chain функций A,B,C,D
      A -> B -> C -> D
      А вызвает функцию B, B вызывает C и т.д
      Допустим А вазывана из main тогда call stack выглядит следующим ообразом:
      etc.
      3> B, строка
      2> A, строка
      1> main, строка  #снизу вверх

      Почему это важно? При ошибках Python вываливает на input как раз этот
      call stack, поэтому error log в питоне может быть длинным

# Лекция 4
1) `List как массив данных`
       
    Объявляем лист A 
      A = [1,2,3,4,5]
      for x in A:
        x += 1
        print(x)    -  выведет 2,3,4,5,6 

    `!!!ВАЖНО`
    Тип данных List является immutable

    Теперь о доступе к элементам списка
    У каждого элемента в списке есть индекс (начинается с 0)

    Возведём в степень элементы листа A
        for k in range(5):
            A[k] = A[k]**2

    Чтобы создать супер длинный массив:
        A = [0] * 1000
        Теперь там все элементы 0

    Чтобы их изменить через цикл for
        for k n range(1000):
            A[k] = k + 1

2) `Линейный поиск в массиве`

      Напишем функцию
      def array_search(A:list,N:int, x:int):  # Передаем три аргумента
            """Осуществляет поиск числа x в массиве A
               от 0 до N-1 индекса включительно.
               Возвращает инедкс элемента x в массиве A
               или -1 если такого нет. Если в массиве несколько
               элементов равных х, то вернуть иднекс
               первого из них
            """
           
            pass

      А теперь протестим
      def array_search_test():
            A1 = [1,2,3,4,5]
            m = array_search(A1,5,8)
            if m == -1:
                  print()

